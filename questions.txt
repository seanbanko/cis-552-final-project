
Questions for Harry / us to answer:

- Thoughts on the best way to enforce the difference between NFAs and DFAs?
    - Do not distinguish between the types and rely on an isDFA function to test that the transition function is injective 
    - Define a DFA exactly the same as an NFA but with transition function State -> Char -> State instead of State -> Char -> (Set State)

- Thoughts on what to do about the empty string aka epsilon?
    
    Idea 1: Epsilon is a special symbol:

        data Symbol =
        | Char :: Char -> Symbol
        | Epsilon :: Symbol
        and then a string is a list of symbols:
        newtype symbolStr = [Symbol]

        or even more simply,

        epsilon :: Char
        epsilon = toEnum 949
        and a regular String = [Char] type works

        This would make processing string simpler.
        But what is the empty string then? [epsilon]? [epsilon, epislon]? are these all valid empty strings?

    Idea 2: Just make it the empty string [] / ""

        This more accurately captures what it is supposed to be but potentially makes processing awkward because
        the transition function is supposed to take a Char, not a String aka [Char]

    Idea 3: Define the transition function in terms of Maybe Chars and then the empty string is Nothing?

        Potentially adds unnecessary complication

-  How can we enforce the totality of our transition function (without GADTs)?
    - i.e. we want to enforce that each state defines a transition for each symbol
    - even though reprsenting the adjacency list with a map does allow for Nothing,
    - a DFA/NFA does not really allow for this. the transition always has to be defined
    - (when we're writing them it just defaults to a rejecting state, so we could do that?)



-- QuickCheck properties
-- TODO difference between function to property and function to Bool? how to use both?

-- Validity properties
-- question to answer/think about: what invariants do we want to enforce
-- TODO how to enforce that transitions are to valid states?



-- Validity property 1: the transition function State -> Char -> State for a DFA is injective

-- Validity property 2: the transition function for an NFA/DFA is total
-- i.e. each state has a transition defined for each char