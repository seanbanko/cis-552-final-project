module NFARegexConvTests where

import FA
import Generators
import NFARegexConv
import RegExp
import Test.HUnit
import Test.QuickCheck

prop_roundTripR :: RegExp -> Property
prop_roundTripR r = toRegExp (toNFA r) %==% r

-- not necessarilly equal, generate the same language

prop_roundTripN :: Ord a => NFA a -> Property
prop_roundTripN nfa = forAll (genString nfa) $
  \s -> acceptN nfa s == acceptN (toNFA (toRegExp nfa)) s

-- not necessarilly equal, accept the same language

-- if you convert a regexp to a nfa, then a string generated by the regexp should be accepted by the nfa
prop_acceptRegExp :: RegExp -> Bool
prop_acceptRegExp = undefined
